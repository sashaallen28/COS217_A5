/*--------------------------------------------------------------------*/
/* bigintadd.s                                                        */
/* Author: Sasha Allen and Tobias Seabold                                            */
/*--------------------------------------------------------------------*/
        .equ    FALSE, 0
        .equ    TRUE, 1

//----------------------------------------------------------------------
        .section .rodata

//----------------------------------------------------------------------
        .section .data

MAX_DIGITS:
        .quad   32768

//----------------------------------------------------------------------
        .section .bss
	
//----------------------------------------------------------------------
        .section .text

        //--------------------------------------------------------------
        /* Return the larger of lLength1 and lLength2. */
        //--------------------------------------------------------------

        // Must be a multiple of 16
        .equ    LARGER_STACK_BYTECOUNT, 32
        
        // Local variable stack offsets:
        .equ    LLARGER, 8

        // Parameter stack offsets:
        .equ    LLENGTH2,   16
        .equ    LLENGTH1,    24

        .global BigInt_larger
        
        
BigInt_larger:
 
			  // Prolog
        sub     sp, sp, LARGER_STACK_BYTECOUNT
        str     x30, [sp]
        str     x0, [sp, LLENGTH1]
        str     x1, [sp, LLENGTH2]
        str x2, [sp, LLARGER]

        // long lLarger;
     
			  // if (lLength1 < lLength2) goto length1Smaller;
        cmp     x0, x1
        blt     length1Smaller
        
        // lLarger = lLength1;
        ldr     x0, [sp, LLENGTH1]
        str     x0, [sp, LLARGER]
				
			  // goto endLarger;
			  b    endLarger
			      
	length1Smaller:
			  // lLarger = lLength2;
			  ldr     x0, [sp, LLENGTH2]
        str     x0, [sp, LLARGER]
			  
			  // goto endLarger;
			 b endLarger
			      
	endLarger:
	      // Epilog and return lLarger
        ldr     x0, [sp, LLARGER]
        ldr     x30, [sp]
        add     sp, sp, LARGER_STACK_BYTECOUNT
        ret

        .size    BigInt_larger, (. -  BigInt_larger)
 

        //--------------------------------------------------------------
        /* Assign the sum of oAddend1 and oAddend2 to oSum.  oSum should be
		       distinct from oAddend1 and oAddend2.  Return 0 (FALSE) if an
           overflow occurred, and 1 (TRUE) otherwise. */
        //--------------------------------------------------------------
.global BigInt_add

BigInt_add:
    // Must be multiple of 16
    .equ ADD_STACK_BYTECOUNT, 64

    .equ ULCARRY, 8
    .equ ULSUM, 16
    .equ LINDEX, 24
    .equ LSUMLENGTH, 32
    .equ OSUM, 40
    .equ OADDEND2, 48
    .equ OADDEND1, 56

    sub sp, sp, ADD_STACK_BYTECOUNT
    str x30, [sp]
    str x0, [sp, OADDEND1]
    str x1, [sp, OADDEND2]
    str x2, [sp, OSUM]

    // lSumLength = BigInt_larger(oAddend1->lLength, oAddend2->lLength)
    ldr x0, [sp, OADDEND1]   // oAddend1
    ldr x0, [x0]             // oAddend1->lLength
    ldr x1, [sp, OADDEND2]   // oAddend2
    ldr x1, [x1]             // oAddend2->lLength
    bl BigInt_larger
    str x0, [sp, LSUMLENGTH]

    // if (oSum->lLength > lSumLength) memset(oSum->aulDigits,0,...)
    ldr x0, [sp, OSUM]       // oSum
    ldr x1, [x0]             // oSum->lLength
    ldr x2, [sp, LSUMLENGTH] // lSumLength
    cmp x1, x2
    ble skip_clear

    add x0, x0, 8            // oSum->aulDigits
    mov x1, 0
    ldr x2, =MAX_DIGITS
    lsl x2, x2, 3
    bl memset

skip_clear:
    // ulCarry = 0; lIndex = 0
    mov x2, 0
    str x2, [sp, ULCARRY]
    mov x2, 0
    str x2, [sp, LINDEX]

loop_add:
    ldr x0, [sp, LINDEX]
    ldr x1, [sp, LSUMLENGTH]
    cmp x0, x1
    bge end_loop

    // ulSum = ulCarry
    ldr x0, [sp, ULCARRY]
    str x0, [sp, ULSUM]
    mov x1, 0
    str x1, [sp, ULCARRY]

    // ulSum += oAddend1->aulDigits[lIndex]
    ldr x1, [sp, LINDEX]
    ldr x2, [sp, OADDEND1]
    add x2, x2, 8
    ldr x3, [x2, x1, lsl 3]
    ldr x0, [sp, ULSUM]
    add x0, x0, x3
    str x0, [sp, ULSUM]

    // if (ulSum < oAddend1->aulDigits[lIndex]) ulCarry = 1
    cmp x0, x3
    bhs skip_carry1
    mov x4, 1
    str x4, [sp, ULCARRY]
skip_carry1:

    // ulSum += oAddend2->aulDigits[lIndex]
    ldr x2, [sp, OADDEND2]
    ldr x3, [x2, x1, lsl 3]
    ldr x0, [sp, ULSUM]
    add x0, x0, x3
    str x0, [sp, ULSUM]

    // if (ulSum < oAddend2->aulDigits[lIndex]) ulCarry = 1
    cmp x0, x3
    bhs skip_carry2
    mov x4, 1
    str x4, [sp, ULCARRY]
skip_carry2:

    // oSum->aulDigits[lIndex] = ulSum
    ldr x0, [sp, OSUM]
    add x0, x0, 8
    ldr x1, [sp, LINDEX]
    ldr x2, [sp, ULSUM]
    str x2, [x0, x1, lsl 3]

    // lIndex++
    ldr x0, [sp, LINDEX]
    add x0, x0, 1
    str x0, [sp, LINDEX]
    b loop_add

end_loop:
    // if (ulCarry == 1)
    ldr x0, [sp, ULCARRY]
    cmp x0, 1
    bne no_final_carry

    // if (lSumLength == MAX_DIGITS) return FALSE
    ldr x0, [sp, LSUMLENGTH]
    mov x1, MAX_DIGITS
    cmp x0, x1
    bne add_final_carry
    mov w0, FALSE
    ldr x30, [sp]
    add sp, sp, ADD_STACK_BYTECOUNT
    ret

add_final_carry:
    // oSum->aulDigits[lSumLength] = 1
    ldr x0, [sp, OSUM]
    add x0, x0, 8
    ldr x1, [sp, LSUMLENGTH]
    mov x2, 1
    str x2, [x0, x1, lsl 3]

    // lSumLength++
    ldr x0, [sp, LSUMLENGTH]
    add x0, x0, 1
    str x0, [sp, LSUMLENGTH]

no_final_carry:
    // oSum->lLength = lSumLength
    ldr x0, [sp, OSUM]
    ldr x1, [sp, LSUMLENGTH]
    str x1, [x0]

    mov w0, 1
    ldr x30, [sp]
    add sp, sp, ADD_STACK_BYTECOUNT
    ret
